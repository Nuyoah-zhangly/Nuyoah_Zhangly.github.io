---
title: C++高级语言程序设计
categories:
- 计算机
tags:
- c++
---

#  C++ 概述
发给对方

## c++ 的起源和特点

### c++起源

### c++ 特点

c++语言的特点 

1）是全面兼容C,并对C的功能作了不少扩充；

2）是增加了面向对象的机制

具体表现

- C++是C的超集，C++保持与C的兼容，这就是许多C代码不经修改就可以为C所用,用C编写的众多函数库和实用软件可以用于C++中

- C++是一个更好的C它保持了C的简洁、高效、易于接近汇编语言的特点，对C的功能做了不少的扩充，C++编写的程序更加安全，可读性好，代码结构更加合理。

- 编写的程序质量高，从开发时间、费用到形成的软件的可重用、扩展性、可维护性和可靠性等方面有了很大的提升，使得大中型的程序开发变得更加容易。

- 增加了面向对象机制，几乎支持所有面向对象程序设计特征：
  1）抽象数据类型
  2）封装与信息隐蔽
  3）以继承方式实现程序重用
  4）以软件重载、运算符重载和虚函数来实现多态性；
  5）以模板来实现类型的参数化

  C++ 最具意义的特点是支持面向对象的特征（C++既可以面向过程的结构化程序设计，也可以面向对象程序设计）

  ## C++源程序的构成

  ### 简单的C++程序

```c++
// sum.cpp 计算整数之和
#include<iostream>  //编译预处理  如果使用<iostream.h>就不需要使用using namespace std 做声明了
using namespace std；//使用命名空间std  保证对C++标准库的每一个特性都是唯一的不至于发生冲突
int mian(){ //主函数首部
    int x,y,sum; //定义三个整型变量
    cout<<"Please input two integers:"<<'\n'; //提示用户由键盘输入两个整数
    cin>>x; //从键盘输入变量x的值    
    cin>>y; //从键盘输入变量y的值
    sum=x+y; //将x+y的值赋给整数的和sum 
    cout<<"x+y="<<sum<<endl; //输出两个整数的和
    return 0; // 如程序正常结束，向操作系统返回一个值0  
}

```


### C++ 程序的结构特性

一个面向对象的C++程序一般由**类的声明**和**类的使用** 两大部分组成

面向对象程序 1）类的声明部分 2）类的使用部分（由主函数及有关子函数组成）

```c++
//C++ 程序的结构特性示例
#include<iostream>  //编译预处理
using namespaces std; //使用命令空间 std
class A{  //声明一个类，类名为A
    int x,y,z; //声明类A的数据成员
    ...
        fun(){ //声明A的成员函数 fun 
        ...
    }
    ...
};
int mian(){
    A a;  //定义类A的一个对象a
    ...
    a.fun(); //调用对象a的成员函数
    return 0;
}
```

首先声明类A，然后在主函数中创建了类A的对象a,通过面向对象a发送消息，调用成员函数fun(),完成所需要的操作。

### C++程序的编辑、编译、连接和运行

开发C++程序的过程通常包括编辑、编译、连接、运行和调试等步骤。

>  C++ 源程序的扩展名为.cpp

## C++在非面向对象方面的的扩充

### C++的行注释

/* */注释分界符号

//  该注释从 // 开始到行尾结束。

### C++的输入输出

c 的输入  输出

```c
    int i;
    float f;
...
    scanf("%d",i); //输入
    printf("%f",f); //输出

```

c++的输入输出

```c++
    int i;
    float f;
...
    cin>>i; //标准输入流 对象 用于标准输入设备键盘 
    cout<<f; 

```

1）cin 标准输入流对象 ">>" 提取运算符（输入运算符） 
2）count 标准输出流对象 "<<" 插入运算符（输出运算符）  



> cin>>变量  
> 表示将从标准输入流对象cin读取数值传从给右方指定的变量，
>
> cin>>x  表示将从标准输入流对象cin读取数值传从给右方指定的变量，用户从键盘输入的值会自动转换为变量x的类型,并存入变量x内，x必须是就基本数据类型，不能是void。

运算符">>" 允许用户输入一连串数据
cin>>a>>b>>c;  两个数据间用空白符(空格、回车或Tab)分隔

> count<<数据  标准的输出流对象，标准的输出设备 指屏幕 
> 表示将右方变量的值写到标准输出流cout中，即在屏幕中显示。
> cont<<y  //变量y的值将显示在屏幕上，y必须是基本数据类型不能是void
> cout<<a+b<<c; //将a+b的值 和c的值 输出到屏幕上

cin和cont的使用

```c++
#include<iostream>  //必须嵌入头文件
using namespace std;
int main(){
    char name[20];
    cout<<"Hello,your name:"<<endl;
    cin>>name;
    cout<<"My name is " <<name;
    return 0;
}
```

操作符dec、hex、oct的使用 //十进制 十六进制 八进制

```c++
#include<iostream>
using namespace std;
int main(){
    int x = 25;
    cout<<hex<<x<<' '<<dec<<x<<' '<<oct<<x<<'\n';  //'\n'与endl相同
    return 0;
}

```

### 灵活的局部变量说明

c++允许 在代码块的任何地方说明全部变量 而c全局变量声明必须在任何函数之前，局部变量必须集中在可执行语句之前。

### 结构、联合和枚举名可直接作为类型名

在c++中

```c++
Bool done； //不必在枚举前面冠以关键字enum
String str； //不必在结构前冠以关键字struct
```

在c语言中

```c
enum Bool{FALSE,TURE};
struct String{
    chart*ptr;
    int length;
};
```

### const 修饰符

1.
c语言中使用# define来定义常量 

> #define LIMIT 100  

c++ 中用const 来定义常量 （const 定义的整型常量int可以省略）

> const int LIMIT= 100; 

这个常量LIMIT是有类型的，占用存储单元，有地址，可以用指针指向它，但不能修改它，
2.const 与指针一起使用

- 指向常量的指针
- 常指针
- 指向常量的长指针
  1）指向常量的指针是指一个指向常量的指针变量。

如

> const char * name = "zhang" //声明指向常量的指针

声明一个指针为name的变量，它指向一个字符型常量，初始化name为指向字符串"zhang"（使用const不允许改变指针所指的地址中的常量）

> Name[3]='a' ❌

2）常指针是指把指针所指的地址，而不是它指向的对象声明为常量
如

> char * const name = “zhang”   常指针

声明一个名为name的指针变量，该指针是指向字符型数据的常指针。用"zhang"的地址初始化该常指针。

创建一个常指针，就是创建一个不能移动的固定指针，不能改变指针指向的地址，但是它所指地址中的数据是可以改变的。

如

> Name[3] = ‘a’；  ✔ 可以改变指针所指的数据

> name="chen";   ❌ 不能改变指针所指的地址

3）指向常量的常指针是指这个指针本身不能改变，它所指向的地址中数据也不能改变。要声明一个指向常量的常指针，二者都需要声明const

如

> const char * const name ="zhang";  指向常量的常指针

声明一个名为name的指针变量，它是一个指向字符型常量的常指针， “zhang”初始化该指针

> Name[3] = ‘a’；  ❌ 不能改变指针所指地址中的数据

> name="zhang"     ❌ 不能改变指针所指的地址

         常量一旦被建立，在任何程序的任何地方都不能在更改
         与 #definde定义的常量有所不同，const定义的常量可以有自己的数据类型
         函数的形参也可以用const说明，用于保证形参在该函数内部不会被改动


希望通过函数 i_Max求出整型数组a[200]的最大值，函数原型

`int i_Max{const int * ptr};`

调用的格式可以是

`i_Max(a)`  

确保原数组中的数据不被破坏，在函数中对数组元素的操作只许读，不许写。

### 函数原型

在C语言程序中**函数调用的位置**在**函数定义之前**应在 调用之前对所调用的函数作声明

函数声明的形式 C语言建议采用函数原型

如 

在c语言程序中函数原型声明

```c++
#include<iosdio.h>
int add(int a,int b);    //函数原型声明
int main()               //主函数
{ int x,y,sum;           //定义三个整型变量
 printf("Enter two numbers:\n");  //提示用户输入两个数的值
 scanf("%d",&x);                  //从键盘输入变量x的值
 scanf("%d",&y);                  //从键盘输入变量y的值 
 sum=add(x,y);                    //调用函数add将得到的值赋给变量sum
 printf("x+y= % d",sum);         //输出两个数的和sum的值
 return 0;                       
}
int add(int a,int b)  //int add(); add();  定义add函数，函数值为整型   
{            
    int c;           //定义一个函数变量
    c=a+b;          //计算两个数的和
    return c;       //将c的值返回，通过add带回调用出
}
```

在c++中 **函数调用的位置**在**函数定义之前**必须对所调函数作**原型声明**  以说明函数的**名称**、**参数类型**与**个数**以及**函数返回值的类型**，目的是让C++编译的程序进行检查，以确定调用函数的参数以及返回值类型与事先定义的原型是否相符，以保证程序的正确性。

如`int add(int a,int b);` 就是函数add的原型

函数原型语法形式：

> 返回值类型 函数名(参数表)；

函数原型

- 是一条语句
- 必须以分号结束；
- 由函数返回值类型、函数名、参数表(包含所有参数及它们的类型，参数之间用逗号分隔)构成

当一个函数的定义在后,而对它的调用在前时，必须将该**函数原型声明**放在**调用语句**之前；

当一个函数的定义在前，而对它的调用在后时，一般不需要在单给出它的原型声明了，这是 **函数定义说明**的部分起到了**函数原型声明**的作用



如  下边代码是相同的

```c++
int fun(int x,int y);  //函数fun 的原型声明
                       //该原型也可以放在main函数体的语句z=fun(4,6)之前
int main()
{ int z;
 z=fun(4,6);    //调用函数
 return 0;
}
int fun(int x,int y)  //定义函数fun
{
    ...
}

```

```c++
int fun(int x,int y);   //定义函数fun
{
    ...
}
int main()
{ int z;
 z=fun(4,6);     //调用函数fun
 retun 0;
   
}
```

1)`函数原型的参数表`不包含**参数的名字**，只包含**它们的类型**

`long Area(int ,int )`    返回类型为long、有两个整型参数、函数名为Area的函数

带有参数的同一函数原型可以 写成 `long Area(int length,int width)`

2)`函数定义`由**函数说明**和**函数体**两部分构成 

`函数说明`部分与`函数原型`基本一样，但`函数说明`部分中的参数必须给出`参数的名字`，而且不能包含结尾的分号。

如

```c++
long Area(int length;int width)  //函数的说明部分
{
    ...
        return (width*length)
}
```

3)`主函数mian`不必进行原型说明，被看成一个自动说明原型的函数，是第一个被执行的函数，而且不存在被别的函数调用的问题

4）**原型说明中**没有指出返回类型的函数(包括主函数main)，c++默认返回值类型`int`

如

> cal(float a, int c);           默认返回类型是int

> int cal(float a,int c)         指明返回类型int型

标准c++中要求`mian`函数必须声明为`int`型，即要求主函数带回一个**整型**函数值。

c++通常是这样处理的，如果程序正常结束，则在main函数后边加一条语句“`return 0；`”，向操作系统返回值0，如果函数执行不正常，则返回数值-1。

5）如果一个函数没有返回值，则必须在函数原型中注明返回值类型`void`,函数最后就不必有`return；` 之类的返回语句。`void main()` 也可编译通过

6）函数原型未注明参数，c++会假定参数表为空(void)

如

在c++中原型说明一样

> f();           表示该函数不带任何参数

> f(void);     表示该函数不带任何参数

在c语言中原型说明不同

> f(void);      表示该函数不带任何参数

> f();             表示该函数的参数信息没有给出，它有可能带有参数

### 内联函数

在函数说明前加关键字`inline`，该函数就被声明**内联函数**，又称为**内置函数**。

当出现对该函数调用时，c++编译器使用函数体中的代码插入到调用该函数的语句出，同时用实参取代形参，一遍在程序运行时不在进行函数调用。

？？？为甚要使用`内联函数`。

*为了消除函数调用时的系统开销，以提高函数运行速度*

我们知道

在函数执行过程中调用函数，系统要将程序当前的一些状态信息存到栈中，同时转到函数的代码处去执行函数体语句，这些参数保存与传递的过程中需要时间和空间的开销，使程序执行效率降低，特别使在程序频繁调用函数时，问题会更加严重。

如 

将函数指定为内联函数

```c++
#include <iostream>
using namespace std;
inline int box(int i,int j,int k);  //函数原型
int mian (){
    int a,b,c,v;
    cin>>a>>b>>c;
    v=box(a,b,c);
    cont<<"a*b*c="<<v<<endl;
    return 0;
}
inline int box(int i,int j,int k)  //定义box 为内联函数
{
   return i*j*k;
}


```

1)内联函数在第一次被调用之前必须进行完成的定义

2）内联函数体一般不能有复杂的控制语句。

3）一般只由规模很小的（1-5）条语句而使用频繁的函数才会定义为内联函数，（会提高运行速度）

4）c++的内联函数与c中带参宏定义`#define`有些相似，但不完全相同。

`宏定义`是在编译前由预编译程序对其处理（做简单的字符转置，不做语法检查，会出现意想不到的错误）

如

使用带参宏定义完成乘2的功能

```c
#include<iostream>
using namespace std;
#defind doub(x) x*2
int main()
{ for (int i=1,i<=3;i++){
   cout<<i<<"doubled is"<<doub(i)<<endl;
    cout<<"1+2 doubled is "<<doub(1+2)<<endl;   //会被置换  编译为     cout<<"1+2 doubled is"<<1+2*2<<endl;
    return 0;
}
}

```

使用内联函数完成乘2的功能

```c++
#include<oistream>
using namespace std;
inline int doub(int x);
int main()
{  for (int i = 1;i<= 3;i++)
    cout<<i<<"doubled is"<<doub(i)<<endl;
    cout<<"1+2 doubled is "<<doub(1+2)<<endl;
 return 0;
}
inline int doub(int x)
{
    return x*2;
}
```

内联函数优于带参宏定义，由内联函数一般不在用宏定义#defind

### 带有默认参数的函数

c++允许实参个数和形参个数不同

方法：在说明函数原型时(若没有说明函数原型,则应在函数定义时)，为一个或多个形参指定默认值

如

一个函数原型说明为：

```c++
int spacial(int x=5;float y=5.3);

```

若未指定足够的实参，则编译系统按顺序用函数原型中的形参默认值来弥补所缺的实参。

```c++
spacial(100,78,8) //x=100;y=78.8
```

```c++
spacial(25)     //相当于special(25,5.3)  结果为x=25,y=5.3
```

```c++
spacial()       //相当于special(5,5.3)  结果为x=5,y=5.3
```

1)在声明函数时，所指定默认值的参数都必须出现在不指定默认值参数的右边。（实参与形参结合是从左至右的顺序进行的。

> int fun (int i,int j=5;int k）❌

> int fun (int i ,int k,int k =5 ✔

2)在`函数调用`时某个参数省略，则其后边的参数都应省略而不采用默认值，不允许某个参数省略后，在给其后的参数指定参数值。

> special(,21.3) ❌

3）如果`函数的定义`在`函数的调用`之前，则应在**函数定义**中指定默认值。

 如果`函数的定义`在`函数的调用`之后，则`函数调用之前`需要有**函数声明**,此时必须在`函数声明`中给出默认值,在`函数定义`时就不要给出默认值了(因为如果函数声明和函数定义都给了默认值，可能有的c++编译系统会给出"重复指定默认值"会出现重复定义的)。

### 函数重载

c语言中，函数名必须时唯一的，不允许出现同名函数。如，当要求编写整型，长整型，双精度的的二次方函数时需要编写三个函数，并且不允许同名，

> Isquare(int i);     求整型的二次方

> Lsquare(long I); 求长整型的二次方

> Dsquare(double d) 求双精度的二次方

c++中，函数可以`重载`，只要函数参数的类型不同，或者参数的个数不同或者二者兼有之，两个或者两个以上的函数可以使用相同的函数名。

**函数重载**是两个或者两个以上的函数共用一个函数名，被重载的函数称为**重载函数**

c++中对于上边三个不同求二次方的函数 只需要编写一个共同的函数，但他们的参数类型仍然保留不同。

如

参数类型不同的函数重载

```c++
#include<iostream>
using namespace std;
int square(int i)
{
    return i*i;
}
long square(long l)
{
    return l*l;
}
double square(double d)
{
    return d*d;
}
int main()
{
 int i=12;
 long l = 1234;
 double d = 5.57;
 cout<<i<<'*'<<i<<'='<<sqare(i)<<endl;   //12*12 = 144
 cout<<l<<'*'<<l<<'='<<sqare(l)<<endl;   //1234*1234=1522756 
 cout<<d<<'*'<<d<<'='<<sqare(d)<<endl;    //5.67*5.67=32.1489
 return 0;
}
```

如 

两个参数个数不同的函数重载

```c++
#include<iostream>
using namespace std;
int mul(int x,int y)
{
    return x*y;
}
int mul(int x,int y,int z)
{
    return x*y*z;
}
int main (){
    int a=3,b=4,c=5;
    cout<<a<<'*'<<b<<'='<<mul(a,b)<<endl;  //3*4=12
    cout<<a<<'*'<<b<<'*'<<c<<'='<<mul(a,b,c)<<endl;  //3*4*5=60
}

```

1)调用函数重载函数时，`函数返回值类型`不在参数匹配检查之列，若两个函数的参数个数和类型都相同，而只有返回值类型不同，则不允许重载。

如

> int mul(int x,int y);

> double mul(int x,int y);

这两个函数的返回值类型不同，但是由于**参数个数**和**类型**完全相同，c++编译系统无法从函数调用形式上判断哪一个函数与之相匹配。

2）函数的重载与带默认值的函数一起使用时，有可能引起二义性

如

> void Drawcircle(int r = 0,int x = 0,int y = 0);

> void Drawcircle(int r);

当执行Drawcircle(20);  编译系统无法确定调用哪一个函数。

3） 在函数调用时，如果实参和形参的类型不相符，c++会自动做出类型转换工作。转换成功，则程序继续执行

但在这种情况下可能产生不可识别的错误。

如

有两个函数的原型如下：

> void f_a(int x);

> void f_a(long x);

虽然满足函数重载的条件，但如果用int c =f_a(5,56)去调用，就会出先不可分辨的错误。

### 作用域运算符 ::

有两个同名变量一个全局的，一个局部的，`局部变量`在其作用域内有较高的优先权，它将屏蔽全局变量。

如

```c++
#include<iostream>
using namespace std;
int avar = 10;     
int main()
{
    int avar;
    avar = 25;
    cout<<"avar is"<<avar<<endl;     //输入局部变量的值25  avar is25
    return 0;
}
```

如

作用域运算符的使用

```c++
#include<iostream>
using namespace std;
int avar;
int main()
{
    int avar;
    avar=25;     
    ::avar=10;
    cout<<"local avar="<<avar<<endl;  //local avar=25
    cout<<"global avar="<<::avar<<endl; //global avar=10
    return 0;
}
```

**作用域运算符**可以解决局部变量与全局变量的重名问题，即在局部变量的作用域内，可用`::`对被屏蔽的全局变量进行访问。

### 无名联合

在c语言中，声明联合（共同体）的类型一般为：

>union 联合类型名
>
>{
>
>成员列表
>
>}

定义联合变量的形式

> 联合类型名 联合变量名：

如

```c++
union data
{
    int i;
    double d;
}a,b,c;
```

`无名联合`是c++中的一种特殊联合，它在关键字`union`后边没有给出联合名，它可使一组数据成员共享同一**内存地址**

如

```c++
union
{
    int i;
    double d;   
}x;
```

无名联合变量x中的整型成员i，双精度型d具有相同的存储地址。
在访问无名变量时，不能访问无名联合变量,而应访问联合变量中的成员。

如

> x.i    访问无名联合变量x中的整型成员i

> x.d   访问无名联合变量x中的双精度成员d

### 强制类型转换

在c语言表达式中不同类型的数据会自动转换类型

如

把一个整型转换为双精度型(double) 

> int  i = 10;
>
> double x = (double) i;

c++支持这样的格式，还可以写成

> int i = 20;
>
> double x = double(i);    推荐使用这种

### 运算符new 和 delete

c语言中使用函数malloc 和free**动态分配内存**和**释放动态分配的内存**，

c++中使用运算符`new`和`delect`更好的，更简单的进行内存的分配和释放

运算符`new`使用内存分配的基本形式:

指针变量名 = new 类型；

*在程序运行过程中，运算符`new`从称为堆的一块自由存储区中为程序分配一块与类型字节数相适应的存储空间，并将该块内存的首地址存于指针的变量中。*

如

> int * p;  定义一个整型指针 变量p

> p = new int；new动态分配存放一个整数的内存空间，并将其首地址赋给指针变量p

运算符`delete` 用于释放运算符`new`分配的存储空间。基本形式为

> delete 指针变量名；

其中，指针变量保存着`new`分配的内存的首地址。

如

> delete p;   将new动态分配的存储空间释放(其首地址已存放在指针变量p中)

使用new和delete的例子

```c++
#include<iostream>
using namespace std;
int main()
{
    int *ptr;   //定义一个整型的指针变量int
    ptr=new int; //动态分配一个整型的存储空间，并将首地址赋给ptr
    *ptr = 10;  
    cout<<*ptr;   //运行结果为10
    delete ptr;   //释放指针ptr指向的存储空间
    return 0;
}

```

该程序定义了一个整型指针变量ptr，用new分配了一块存放一个整型的内存空间，并将首地址赋给指针变量ptr，然后在这内存块中赋予初值10，并将其打印出，最后释放ptr指向的内存空间。

优点：

1）使用`malloc`函数时必须使用sizeof函数来计算所需要的字节数，而`new`可以根据数据类型自动计算所要分配内存的大小，减少错误发生的可能性。

2）`new`能够自动返回正确的指针类型，不用向`malloc`函数那样，必须在程序中进行强制类型转换，才能使其返回正确的指针类型。

- 使用`new`可以为数组动态分配内存空间，需要在类型名后面加上`数组大小`

如 

> int*pi = new int[10];

这时new 为具有10个数组元素的整型数组分配了内存空间，并将其首地址赋给了指针pi

使用new 为多维数组分配内存空间时，必须提供所有维的大小。

如

> int * pi = new int [2] [3] [4]

其中，第一维的界值可以是任意合法的正整数表达式

如

>int i = 3;
>
>int *pi = new [2] [3] [4];



- new 可以为简单变量分配内存的同时，进行初始化。基本形式

> 指针变量名 = new 类型(初值)

```c++
#include<iostream>
using namespace std;
int main()
{int *p;
 p = new int(99);  //动态分配内存空间，并将99作为初始值赋给它
 cout<<*p;
 delete p;
 return 0;
}
```

但是new不能对动态分配的`数组存储区`进行初始化。

- 释放动态分配的数组存储区时，可以使用`delete`格式

> delete [ ]指针变量名

在此指针变量名前只用`一对`方括号符，无需指出所删除数组的维数和大小。

- 使用new动态分配地址时，如果没有足够的内存满足分配要求，则动态分配失败，有些编译系统将返回空指针`NULL`,可以对内存的动态分配是否成功进行检验。

对动态分配是否成功进行检查

```c++
#include<iostream>
using namespace std;
int main()
{int *p;
 p = new int;
 if(!p)
 {
     cout<<"allocation failure\n";   //若分配失败，屏幕上将会出现allocation failure 
     return 1;
 }
 *p =20;
 cout<< *p;
 delete p;
 return 0;   
}
```



内存动态分配成功后不宜变动指针的值，否则释放存储空间时会引起系统内存管理失败。

- 用new分配的存储存储空间不会自动释放，只能同过delete释放，要适时的释放动态分配的存储空间。

### 引用

1. 引用的概念
   作用是为变量另起一个名字，`变量的引用`通常被认为是变量的别名。
   当声明了一个引用时，必须同时对另一个变量的名字来将它进行初始化。即*声明它代表哪一个变量*,是哪一个变量的别名。(对一个引用的所有操作都是在对其所代表的变量的操作)。

  格式如下

  > 类型 &引用名=已定义的变量名；

  ```c++
int i = 5;
int &j = i; //声明j是一整型变量的引用，用整型变量i对其进行初始化
  ```

  j是一个整型变量的引用，用整型变量i对其进行初始化，这是j就是变量i的引用，即是变量i的别名。

  `&` 是**引用声明符**，此时它不代表地址。

  对变量声明一个引用，并不另外开辟内存单元，变量i和引用j占用内存的同一位置。

  变量和引用的关系

  ```c++
#include<iostream>
using namespace std;
int main()
{ int i;
 int &j=i;           //声明j是一个整型变量i的地址
 i=30; 
 cout<<"i="<<i<<"j="<<j<<"\n";  //输出变量i和引用的值  i=30j=30
 j=80;
 cout<<"i="<<i<<"j="<<j<<"\n"; //输出变量i和引用的值   i=80j=80
 cout<<"变量i的地址:"<<&i<<"\n"; //输出变量i的地址  变量i的地址:0x61fe14
 cout<<"引用j的地址:"<<&j<<"\n"; //输出变量j的地址 引用j的地址:0x61fe14  此地址会根据实际运行有所不同
 return 0;
}
  ```

  1）`引用名`可以使用任何合法的变量名，除了用作函数的参数或返回类型外，在声明引用时，必须立即对它进行初始化，不能声明完成后在赋值

```c++
int i;
int &j;       //❌没有指定j代表那个变量
j=i;       
```

2）为`引用`提供的初始值可以是一个**变量**或者`另一个引用`

如

```c++
int i =5; //定义一个整型变量i
int &j1=i; //声明j1是整型变量i的引用(别名)
int &2=j1; //声明j2是整型变量j1的引用(别名)
```



变量i有两个别名j1和j2

3)指针是通过地址间接访问某个变量，而`引用`是通过别名直接访问某个变量。

每次使用引用时，可以不用书写`间接运算符"*"`，引用可以简化程序

比较引用和指针使用的方法

```c++
#include<iostream>
using namespace std;
int main()
{
    int i= 15;    //定义一个整型变量i,赋初值15
    int *iptr=&i;  //定义指针变量iptr，将变量i的地址赋给iptr
    int &rptr=i;    //声明变量i的引用rptr，rptr是变量i的别名
    cout<<"i is "<<i<<endl;   //输出i的值     
    cout<<"* iptr is "<<*iptr<<endl; //输出*iptr的值
    cout<<"rptr is "<<rptr<<endl; //输出rptr的值
    i=29;   
    cout<<"After changing i to 29:"<<endl;
    cout<<"i is "<<i<<endl;  //输出i的值 
    cout<<"* iptr is "<<*iptr<<endl;  //输出*iptr的值
    cout<<"rptr is "<<rptr<<endl;  //输出rptr的值
    return 0;
}
```

使用`指针变量`iptr所指的变量i，必须用`*`来间接引用指针

使用`引用`rptr所代表的变量i，不用写间接引用运算符

4）`引用`在初始化后不能在被重新声明为另一个变量的引用（别名）

```c++
int i,k;   //定影一个整型变量k
int &j=i;   //声明j是整型变量i的引用(别名)
j=&k;   // ❌ 企图重新声明j的整型变量k的引用(别名)
```

5）并不是所有类型的数据都可以`引用`,

+ 不允许建立`void`的类型引用 

> void &r = 10;     ❌

void 只是在语法上相当于一个类型，本质上不是类型，void的含义是`无类型或空类型`，任何实际存在的变量都属于非void类型。

- 不能建立`引用`的数组

> int a [4] = "abcd";
>
> int   &ra[4] = a；      ❌ 不能建立引用数组

- 不能建立引用的引用，不能建立指向指针的引用。引用本身不是一种数据类型，所以没有引用的引用，也没有引用的指针。

  >int n = 3;     
  >
  >int &&r = n;  ❌ 不能建立引用的引用
  >
  >int &*p = n;   ❌ 不能建立指向引用的指针

  6)可以将一个引用的地址赋给一个指针，此时指针指向的是原来的变量

  > int num = 50;
  >
  > int &ref = num;
  >
  > int  *p = &ref;

  

p中保存的是原来变量num的地址。

7)引用运算符和地址操作符使用相同的符号`&`，`引用`仅在声明时带有引用运算符`&`,以后就像普通变量一样使用，不能再带有`&`,，其他场合使用的`&`都是地址操作符。

```c++
int j = 5;
int &i = j;   //声明引用i，"&"为引用运算符
i =123;       //使用引用i,不带引用运算符
int *pi = &i;  //这里的 &为地址操作符
cout<<&pi;   // 这里的也为地址操作符
```

2.引用作为函数参数

引用的主要用途是将`引用`作为函数的参数

指针变量作为函数参数的例子

```c++
#include<iostream>
using namespace std;
void swap(int * m,int * n)
{
    int temp;
    temp = * m;
    * m = * n;
    * n = temp;
}
int main ()
{
    int a =5,b =10;
    cout<<"a="<<a<<" b="<<b<<endl;  //a=5 b=10
    swap(&a,&b);
    cout<<"a="<<a<<" b="<<b<<endl;  //a=10 b=5
    return 0;
}
```

采用指针变量作为函数参数，调用函数swap后a和b的值被交换了

引用作为函数的参数

```c++
#include<iostream>
using namespace std;
void swap(int &m,int &n)  //形参m和n是整型变量的引用
{
    int temp;
    temp = m;
    m = n;
    n = temp;
}
int main()
{
    int a = 5,b =10;
    cout<<"a= "<<a<<"b="<<b<<endl;   //a= 5 b=10
    swap(a,b);   //实参a和b是整型变量,可以通过引用来修改实参a和b的值
    cout<<"a= "<<a<<"b= "<<b<<endl;  //a= 10 b= 5
    return 0;
}
```

当程序中调用swap时参数a和b分别初始化引用m和n，m、n分别是变量a、b的别名，对m、n的访问就是对a、b的访问，函数swap调用后引用m、n的值被交换了，所以a、b的值也被交换了。c++主张采用引用作为函数的参数。

3.使用引用返回函数值

引用返回函数值这种方法，可以将该函数调用放在赋值运算符的左边。

```c++
#include<iostream>
using namespace std;
int a[] = {1,3,5,7,9};
int &index(int);              //声明函数返回一个整型的引用
int main()
{
    index(2)= 25;             //将函数调用放在赋值运算符的左边 等价于a[2]赋值为25
    cout<<index(2);           //等价于输出数组元素a[2]的值    运行结果为25
    return 0;
}
int &index(int i)
{
    return a[i];              //定义函数返回一个整数类型的引用，等价于返回数组元素a[i]
}
```

除了将函数定义为返回`引用`外，通常一个函数不能直接用在`赋值运算符的左边`

如

将上例中，index定义成

```c++
int index(int i)
{
   return a[i];    
}
    
```

编译时语句 `index(a)=25`出错，而语句`cout<<index(2)`可以通过为什么❓

4.引用举例

应用引用的综合例子

```c++
#include<iostream>
using namespace std;
int &max(int &num1,int &num2);
int &min(int &num1,int &num2); 
int mian()
{
    int num1,num2;
    cout<<"请输入第1个数:";                    //请输入第1个数
    cin>>num1;                                //45
    cout<<"请输入第2个数:";                   //请输入第2个数
    cin>>num2;                               //78
    max(num1,num2) = 0;
    cout<<"\n找出最大数,然后把最大数赋值为0后,两个数分别为:"<<endl;    //找出最大数，然后把最大值赋值给0后,两个数分别为：
    cout<<num1<<"和"<<num2<<endl;   //45 和 0
    cout<<"现在，请在输入两个数:"<<endl;
    cout<<"请输入第一个数:"<<endl;        //请输入第1个数
    cin>>num1;                           //13
    cout<<"请输入第2个数:"<<endl;         //请输入第2个数
    cin>>num2;                            //56
    min(num1,num2) =0;
    cout<<"\n找出最小数，然后把最小数赋值给0,两个数分别为:"<<endl;  //找出最小数，然后把最大值赋值给0后,两个数分别为：
    cout<<numl<<"和"<<num2<<endl;   // 0和56
    return 0;
}
int &max(int &num1,int &num2)
{
    return (num1>num2)?num1:num2;
}
int &min(int &num1,int &num2)
{
    return (num1<num2)?num1:num2;
}
```

如果没有使用`引用返回值`功能,就需要把max(num1,num2)和min(num1,num2) = 0

扩展成if_else语句，就必须先找出最大数然后，把最大数赋值给0，找出最小值也类似。



